<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README.rdoc</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README.rdoc</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README.rdoc
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Thu Jun 18 04:20:14 -07:00 2009</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
<a href="../classes/Haml.html">Haml</a> and <a
href="../classes/Sass.html">Sass</a> are templating engines for the two
most common types of documents on the web: HTML and CSS, respectively. They
are designed to make it both easier and more pleasant to code HTML and CSS
documents, by eliminating redundancy, reflecting the underlying structure
that the document represents, and providing elegant, easily understandable,
and powerful syntax.
</p>
<h2>Using</h2>
<p>
There are several ways to use <a href="../classes/Haml.html">Haml</a> and
<a href="../classes/Sass.html">Sass</a>. They can be used as a plugin for
Rails or <a href="../classes/Merb.html">Merb</a>, or embedded on their own
in other applications. The first step of all of these is to install the <a
href="../classes/Haml.html">Haml</a> gem:
</p>
<pre>
  gem install haml
</pre>
<p>
To install <a href="../classes/Haml.html">Haml</a> and <a
href="../classes/Sass.html">Sass</a> as a Rails plugin, just run <tt>haml
&#8212;rails path/to/rails/app</tt> and both <a
href="../classes/Haml.html">Haml</a> and <a
href="../classes/Sass.html">Sass</a> will be installed. Views with the
<tt>.haml</tt> (or <tt>.html.haml</tt> for edge) extension will
automatically use <a href="../classes/Haml.html">Haml</a>. <a
href="../classes/Sass.html">Sass</a> is a little more complicated;
<tt>.sass</tt> files should be placed in public/stylesheets/sass, where
they&#8216;ll be automatically compiled to corresponding CSS files in
public/stylesheets when needed (the <a href="../classes/Sass.html">Sass</a>
template directory is customizable&#8230; see the <a
href="../classes/Sass.html">Sass</a> module docs for details).
</p>
<p>
For <a href="../classes/Merb.html">Merb</a>, <tt>.html.haml</tt> views will
work without any further modification. To enable <a
href="../classes/Sass.html">Sass</a>, you also need to add a dependency. To
do so, just add
</p>
<pre>
  dependency &quot;merb-haml&quot;
</pre>
<p>
to config/dependencies.rb (or config/init.rb in a flat/very flat <a
href="../classes/Merb.html">Merb</a> application). Then it&#8216;ll work
just like it does in Rails.
</p>
<p>
To use <a href="../classes/Haml.html">Haml</a> and <a
href="../classes/Sass.html">Sass</a> programatically, check out the RDocs
for the <a href="../classes/Haml.html">Haml</a> and <a
href="../classes/Sass.html">Sass</a> modules.
</p>
<h2>Formatting</h2>
<h3><a href="../classes/Haml.html">Haml</a></h3>
<p>
The most basic element of <a href="../classes/Haml.html">Haml</a> is a
shorthand for creating HTML tags:
</p>
<pre>
  %tagname{ :attr1 =&gt; 'value1', :attr2 =&gt; 'value2' } Contents
</pre>
<p>
No end-tag is needed; <a href="../classes/Haml.html">Haml</a> handles that
automatically. Adding <tt>class</tt> and <tt>id</tt> attributes is even
easier. <a href="../classes/Haml.html">Haml</a> uses the same syntax as the
CSS that styles the document:
</p>
<pre>
  %tagname#id.class
</pre>
<p>
In fact, when you&#8216;re using the <tt>&lt;div&gt;</tt> tag, it becomes
<em>even easier</em>. Because <tt>&lt;div&gt;</tt> is such a common
element, a tag without a name defaults to a div. So
</p>
<pre>
  #foo Hello!
</pre>
<p>
becomes
</p>
<pre>
  &lt;div id='foo'&gt;Hello!&lt;/div&gt;
</pre>
<p>
<a href="../classes/Haml.html">Haml</a> uses indentation to bring the
individual elements to represent the HTML structure. A tag&#8216;s children
are indented two spaces more than the parent tag. Again, a closing tag is
automatically added. For example:
</p>
<pre>
  %ul
    %li Salt
    %li Pepper
</pre>
<p>
becomes:
</p>
<pre>
  &lt;ul&gt;
    &lt;li&gt;Salt&lt;/li&gt;
    &lt;li&gt;Pepper&lt;/li&gt;
  &lt;/ul&gt;
</pre>
<p>
You can also put plain text as a child of an element:
</p>
<pre>
  %p
    Hello,
    World!
</pre>
<p>
It&#8216;s even possible to embed Ruby code into <a
href="../classes/Haml.html">Haml</a> documents. An equals sign, <tt>=</tt>,
will output the result of the code. A hyphen, <tt>-</tt>, will run the code
but not output the result. You can even use control statements like
<tt>if</tt> and <tt>while</tt>:
</p>
<pre>
  %p
    Date/Time:
    - now = DateTime.now
    %strong= now
    - if now &gt; DateTime.parse(&quot;December 31, 2006&quot;)
      = &quot;Happy new &quot; + &quot;year!&quot;
</pre>
<p>
<a href="../classes/Haml.html">Haml</a> provides far more tools than those
presented here. Check out the reference documentation in the <a
href="../classes/Haml.html">Haml</a> module.
</p>
<h3><a href="../classes/Sass.html">Sass</a></h3>
<p>
At its most basic, <a href="../classes/Sass.html">Sass</a> is just another
way of writing CSS. Although it&#8216;s very much like normal CSS, the
basic syntax offers a few helpful features: tabulation (using *two spaces*)
indicates the attributes in a rule, rather than non-DRY brackets; and
newlines indicate the end of an attribute, rather than a semicolon. For
example:
</p>
<pre>
  #main
    :background-color #f00
    :width 98%
</pre>
<p>
becomes:
</p>
<pre>
  #main {
    background-color: #f00;
    width: 98% }
</pre>
<p>
However, <a href="../classes/Sass.html">Sass</a> provides much more than a
way to make CSS look nice. In CSS, it&#8216;s important to have accurate
selectors, so your styles don&#8216;t just apply to everything. However, in
order to do this, you need to use nested element selectors. These get very
ugly very quickly. I&#8216;m sure everyone&#8216;s had to write something
like &quot;main .sidebar .top p h1 a&quot;, followed by &quot;main .sidebar
.top p h1 a:visited&quot; and &quot;main .sidebar .top p h1 a:hover&quot;.
Well, <a href="../classes/Sass.html">Sass</a> gets rid of that. Like <a
href="../classes/Haml.html">Haml</a>, it uses indentation to indicate the
structure of the document. So, what was:
</p>
<pre>
  #main {
    width: 90%;
  }
  #main p {
    border-style: solid;
    border-width: 1px;
    border-color: #00f;
  }
  #main p a {
    text-decoration: none;
    font-weight: bold;
  }
  #main p a:hover {
    text-decoration: underline;
  }
</pre>
<p>
becomes:
</p>
<pre>
  #main
    :width 90%
    p
      :border-style solid
      :border-width 1px
      :border-color #00f
      a
        :text-decoration none
        :font-weight bold
      a:hover
        :text-decoration underline
</pre>
<p>
Pretty nice, no? Well, it gets better. One of the main complaints against
CSS is that it doesn&#8216;t allow constants. What if have a color or a
width you re-use all the time? In CSS, you just have to re-type it each
time, which is a nightmare when you decide to change it later. Not so for
<a href="../classes/Sass.html">Sass</a>! You can use the &quot;!&quot;
character to set constants. Then, if you put &quot;=&quot; after your
attribute name, you can set it to a constant. For example:
</p>
<pre>
  !note_bg= #55aaff

  #main
    :width 70%
    .note
      :background-color= !note_bg
    p
      :width 5em
      :background-color= !note_bg
</pre>
<p>
becomes:
</p>
<pre>
  #main {
    width: 70%; }
    #main .note {
      background-color: #55aaff; }
    #main p {
      width: 5em;
      background-color: #55aaff; }
</pre>
<p>
You can even do simple arithmetic operations with constants, adding numbers
and even colors together:
</p>
<pre>
  !main_bg= #46ar12
  !main_width= 40em

  #main
    :background-color= !main_bg
    :width= !main_width
    .sidebar
      :background-color= !main_bg + #333333
      :width= !main_width - 25em
</pre>
<p>
becomes:
</p>
<pre>
  #main {
    background-color: #46a312;
    width: 40em; }
    #main .sidebar {
      background-color: #79d645;
      width: 15em; }
</pre>
<p>
Taking the idea of constants a bit further are mixins. These let you group
whole swathes of CSS attributes into a single directive and then include
those anywhere you want:
</p>
<pre>
  =blue-border
    :border
      :color blue
      :width 2px
      :style dotted

  .comment
    +blue-border
    :padding 2px
    :margin 10px 0

  .reply
    +blue-border
</pre>
<p>
becomes:
</p>
<pre>
  .comment {
    border-color: blue;
    border-width: 2px;
    border-style: dotted;
    padding: 2px;
    margin: 10px 0;
  }

  .reply {
    border-color: blue;
    border-width: 2px;
    border-style: dotted;
  }
</pre>
<p>
A comprehensive list of features is in the documentation for the <a
href="../classes/Sass.html">Sass</a> module.
</p>
<h2>Executables</h2>
<p>
The <a href="../classes/Haml.html">Haml</a> gem includes several
executables that are useful for dealing with <a
href="../classes/Haml.html">Haml</a> and <a
href="../classes/Sass.html">Sass</a> from the command line.
</p>
<h3><tt>haml</tt></h3>
<p>
The <tt>haml</tt> executable transforms a source <a
href="../classes/Haml.html">Haml</a> file into HTML. See <tt>haml
&#8212;help</tt> for further information and options.
</p>
<h3><tt>sass</tt></h3>
<p>
The <tt>sass</tt> executable transforms a source <a
href="../classes/Sass.html">Sass</a> file into CSS. See <tt>sass
&#8212;help</tt> for further information and options.
</p>
<h3><tt>html2haml</tt></h3>
<p>
The <tt>html2haml</tt> executable attempts to transform HTML, optionally
with ERB markup, into <a href="../classes/Haml.html">Haml</a> code. Since
HTML is so variable, this transformation is not always perfect; it&#8216;s
a good idea to have a human check the output of this tool. See
<tt>html2haml &#8212;help</tt> for further information and options.
</p>
<h3><tt>css2sass</tt></h3>
<p>
The <tt>css2sass</tt> executable attempts to transform CSS into <a
href="../classes/Sass.html">Sass</a> code. This transformation attempts to
use <a href="../classes/Sass.html">Sass</a> nesting where possible. See
<tt>css2sass &#8212;help</tt> for further information and options.
</p>
<h2>Authors</h2>
<p>
<a href="../classes/Haml.html">Haml</a> and <a
href="../classes/Sass.html">Sass</a> are designed by Hampton Catlin
(hcatlin) and he is the author of the original implementation. However,
Hampton doesn&#8216;t even know his way around the code anymore and mostly
just concentrates on the language issues. Hampton lives in Toronto, Ontario
(though he&#8216;s an American by birth) and is a partner at Unspace
Interactive.
</p>
<p>
Nathan Weizenbaum is the primary maintainer and architect of the
&quot;modern&quot; Ruby implementation of <a
href="../classes/Haml.html">Haml</a>. His hard work has kept the project
alive by endlessly answering forum posts, fixing bugs, refactoring, finding
speed improvements, writing documentation, implementing new features, and
getting Hampton coffee (a fitting task for a boy-genius). Nathan lives in
Seattle, Washington and while not being a student at University of
Washington he consults for Unspace Interactive and Microsoft.
</p>
<p>
If you use this software, you must pay Hampton a compliment. And buy Nathan
some jelly beans. Maybe pet a kitten. Yeah. Pet that kitty.
</p>
<p>
Some of the work on <a href="../classes/Haml.html">Haml</a> was supported
by Unspace Interactive.
</p>
<p>
Beyond that, the implementation is licensed under the MIT License. Ok,
fine, I guess that means compliments aren&#8216;t <b>required</b>.
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>